// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.33.2
// source: grpc/proto/scout.proto

package scoutpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ScoutService_CreateSession_FullMethodName  = "/scout.v1.ScoutService/CreateSession"
	ScoutService_DestroySession_FullMethodName = "/scout.v1.ScoutService/DestroySession"
	ScoutService_Navigate_FullMethodName       = "/scout.v1.ScoutService/Navigate"
	ScoutService_Reload_FullMethodName         = "/scout.v1.ScoutService/Reload"
	ScoutService_GoBack_FullMethodName         = "/scout.v1.ScoutService/GoBack"
	ScoutService_GoForward_FullMethodName      = "/scout.v1.ScoutService/GoForward"
	ScoutService_Click_FullMethodName          = "/scout.v1.ScoutService/Click"
	ScoutService_DoubleClick_FullMethodName    = "/scout.v1.ScoutService/DoubleClick"
	ScoutService_RightClick_FullMethodName     = "/scout.v1.ScoutService/RightClick"
	ScoutService_Hover_FullMethodName          = "/scout.v1.ScoutService/Hover"
	ScoutService_Type_FullMethodName           = "/scout.v1.ScoutService/Type"
	ScoutService_SelectOption_FullMethodName   = "/scout.v1.ScoutService/SelectOption"
	ScoutService_PressKey_FullMethodName       = "/scout.v1.ScoutService/PressKey"
	ScoutService_GetText_FullMethodName        = "/scout.v1.ScoutService/GetText"
	ScoutService_GetAttribute_FullMethodName   = "/scout.v1.ScoutService/GetAttribute"
	ScoutService_GetTitle_FullMethodName       = "/scout.v1.ScoutService/GetTitle"
	ScoutService_GetURL_FullMethodName         = "/scout.v1.ScoutService/GetURL"
	ScoutService_Eval_FullMethodName           = "/scout.v1.ScoutService/Eval"
	ScoutService_ElementExists_FullMethodName  = "/scout.v1.ScoutService/ElementExists"
	ScoutService_Screenshot_FullMethodName     = "/scout.v1.ScoutService/Screenshot"
	ScoutService_PDF_FullMethodName            = "/scout.v1.ScoutService/PDF"
	ScoutService_StartRecording_FullMethodName = "/scout.v1.ScoutService/StartRecording"
	ScoutService_StopRecording_FullMethodName  = "/scout.v1.ScoutService/StopRecording"
	ScoutService_ExportHAR_FullMethodName      = "/scout.v1.ScoutService/ExportHAR"
	ScoutService_StreamEvents_FullMethodName   = "/scout.v1.ScoutService/StreamEvents"
	ScoutService_Interactive_FullMethodName    = "/scout.v1.ScoutService/Interactive"
)

// ScoutServiceClient is the client API for ScoutService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ScoutService exposes real-time headless browser control with forensic capture.
type ScoutServiceClient interface {
	// Session lifecycle
	CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*CreateSessionResponse, error)
	DestroySession(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Empty, error)
	// Navigation
	Navigate(ctx context.Context, in *NavigateRequest, opts ...grpc.CallOption) (*NavigateResponse, error)
	Reload(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Empty, error)
	GoBack(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Empty, error)
	GoForward(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Empty, error)
	// Element interaction
	Click(ctx context.Context, in *ElementRequest, opts ...grpc.CallOption) (*Empty, error)
	DoubleClick(ctx context.Context, in *ElementRequest, opts ...grpc.CallOption) (*Empty, error)
	RightClick(ctx context.Context, in *ElementRequest, opts ...grpc.CallOption) (*Empty, error)
	Hover(ctx context.Context, in *ElementRequest, opts ...grpc.CallOption) (*Empty, error)
	Type(ctx context.Context, in *TypeRequest, opts ...grpc.CallOption) (*Empty, error)
	SelectOption(ctx context.Context, in *SelectRequest, opts ...grpc.CallOption) (*Empty, error)
	PressKey(ctx context.Context, in *KeyRequest, opts ...grpc.CallOption) (*Empty, error)
	// Query
	GetText(ctx context.Context, in *ElementRequest, opts ...grpc.CallOption) (*TextResponse, error)
	GetAttribute(ctx context.Context, in *AttributeRequest, opts ...grpc.CallOption) (*TextResponse, error)
	GetTitle(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*TextResponse, error)
	GetURL(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*TextResponse, error)
	Eval(ctx context.Context, in *EvalRequest, opts ...grpc.CallOption) (*EvalResponse, error)
	ElementExists(ctx context.Context, in *ElementRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	// Capture
	Screenshot(ctx context.Context, in *ScreenshotRequest, opts ...grpc.CallOption) (*ScreenshotResponse, error)
	PDF(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*PDFResponse, error)
	// Forensic - network recording
	StartRecording(ctx context.Context, in *RecordingRequest, opts ...grpc.CallOption) (*Empty, error)
	StopRecording(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Empty, error)
	ExportHAR(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*HARResponse, error)
	// Real-time event stream (server -> client)
	StreamEvents(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BrowserEvent], error)
	// Bidirectional: client sends commands, server streams events
	Interactive(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Command, BrowserEvent], error)
}

type scoutServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewScoutServiceClient(cc grpc.ClientConnInterface) ScoutServiceClient {
	return &scoutServiceClient{cc}
}

func (c *scoutServiceClient) CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*CreateSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSessionResponse)
	err := c.cc.Invoke(ctx, ScoutService_CreateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) DestroySession(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_DestroySession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) Navigate(ctx context.Context, in *NavigateRequest, opts ...grpc.CallOption) (*NavigateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NavigateResponse)
	err := c.cc.Invoke(ctx, ScoutService_Navigate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) Reload(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_Reload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) GoBack(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_GoBack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) GoForward(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_GoForward_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) Click(ctx context.Context, in *ElementRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_Click_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) DoubleClick(ctx context.Context, in *ElementRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_DoubleClick_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) RightClick(ctx context.Context, in *ElementRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_RightClick_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) Hover(ctx context.Context, in *ElementRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_Hover_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) Type(ctx context.Context, in *TypeRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_Type_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) SelectOption(ctx context.Context, in *SelectRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_SelectOption_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) PressKey(ctx context.Context, in *KeyRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_PressKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) GetText(ctx context.Context, in *ElementRequest, opts ...grpc.CallOption) (*TextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TextResponse)
	err := c.cc.Invoke(ctx, ScoutService_GetText_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) GetAttribute(ctx context.Context, in *AttributeRequest, opts ...grpc.CallOption) (*TextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TextResponse)
	err := c.cc.Invoke(ctx, ScoutService_GetAttribute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) GetTitle(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*TextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TextResponse)
	err := c.cc.Invoke(ctx, ScoutService_GetTitle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) GetURL(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*TextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TextResponse)
	err := c.cc.Invoke(ctx, ScoutService_GetURL_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) Eval(ctx context.Context, in *EvalRequest, opts ...grpc.CallOption) (*EvalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EvalResponse)
	err := c.cc.Invoke(ctx, ScoutService_Eval_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) ElementExists(ctx context.Context, in *ElementRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, ScoutService_ElementExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) Screenshot(ctx context.Context, in *ScreenshotRequest, opts ...grpc.CallOption) (*ScreenshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScreenshotResponse)
	err := c.cc.Invoke(ctx, ScoutService_Screenshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) PDF(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*PDFResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PDFResponse)
	err := c.cc.Invoke(ctx, ScoutService_PDF_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) StartRecording(ctx context.Context, in *RecordingRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_StartRecording_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) StopRecording(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, ScoutService_StopRecording_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) ExportHAR(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*HARResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HARResponse)
	err := c.cc.Invoke(ctx, ScoutService_ExportHAR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scoutServiceClient) StreamEvents(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BrowserEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ScoutService_ServiceDesc.Streams[0], ScoutService_StreamEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SessionRequest, BrowserEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ScoutService_StreamEventsClient = grpc.ServerStreamingClient[BrowserEvent]

func (c *scoutServiceClient) Interactive(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Command, BrowserEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ScoutService_ServiceDesc.Streams[1], ScoutService_Interactive_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Command, BrowserEvent]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ScoutService_InteractiveClient = grpc.BidiStreamingClient[Command, BrowserEvent]

// ScoutServiceServer is the server API for ScoutService service.
// All implementations must embed UnimplementedScoutServiceServer
// for forward compatibility.
//
// ScoutService exposes real-time headless browser control with forensic capture.
type ScoutServiceServer interface {
	// Session lifecycle
	CreateSession(context.Context, *CreateSessionRequest) (*CreateSessionResponse, error)
	DestroySession(context.Context, *SessionRequest) (*Empty, error)
	// Navigation
	Navigate(context.Context, *NavigateRequest) (*NavigateResponse, error)
	Reload(context.Context, *SessionRequest) (*Empty, error)
	GoBack(context.Context, *SessionRequest) (*Empty, error)
	GoForward(context.Context, *SessionRequest) (*Empty, error)
	// Element interaction
	Click(context.Context, *ElementRequest) (*Empty, error)
	DoubleClick(context.Context, *ElementRequest) (*Empty, error)
	RightClick(context.Context, *ElementRequest) (*Empty, error)
	Hover(context.Context, *ElementRequest) (*Empty, error)
	Type(context.Context, *TypeRequest) (*Empty, error)
	SelectOption(context.Context, *SelectRequest) (*Empty, error)
	PressKey(context.Context, *KeyRequest) (*Empty, error)
	// Query
	GetText(context.Context, *ElementRequest) (*TextResponse, error)
	GetAttribute(context.Context, *AttributeRequest) (*TextResponse, error)
	GetTitle(context.Context, *SessionRequest) (*TextResponse, error)
	GetURL(context.Context, *SessionRequest) (*TextResponse, error)
	Eval(context.Context, *EvalRequest) (*EvalResponse, error)
	ElementExists(context.Context, *ElementRequest) (*BoolResponse, error)
	// Capture
	Screenshot(context.Context, *ScreenshotRequest) (*ScreenshotResponse, error)
	PDF(context.Context, *SessionRequest) (*PDFResponse, error)
	// Forensic - network recording
	StartRecording(context.Context, *RecordingRequest) (*Empty, error)
	StopRecording(context.Context, *SessionRequest) (*Empty, error)
	ExportHAR(context.Context, *SessionRequest) (*HARResponse, error)
	// Real-time event stream (server -> client)
	StreamEvents(*SessionRequest, grpc.ServerStreamingServer[BrowserEvent]) error
	// Bidirectional: client sends commands, server streams events
	Interactive(grpc.BidiStreamingServer[Command, BrowserEvent]) error
	mustEmbedUnimplementedScoutServiceServer()
}

// UnimplementedScoutServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedScoutServiceServer struct{}

func (UnimplementedScoutServiceServer) CreateSession(context.Context, *CreateSessionRequest) (*CreateSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSession not implemented")
}
func (UnimplementedScoutServiceServer) DestroySession(context.Context, *SessionRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DestroySession not implemented")
}
func (UnimplementedScoutServiceServer) Navigate(context.Context, *NavigateRequest) (*NavigateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Navigate not implemented")
}
func (UnimplementedScoutServiceServer) Reload(context.Context, *SessionRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Reload not implemented")
}
func (UnimplementedScoutServiceServer) GoBack(context.Context, *SessionRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method GoBack not implemented")
}
func (UnimplementedScoutServiceServer) GoForward(context.Context, *SessionRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method GoForward not implemented")
}
func (UnimplementedScoutServiceServer) Click(context.Context, *ElementRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Click not implemented")
}
func (UnimplementedScoutServiceServer) DoubleClick(context.Context, *ElementRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DoubleClick not implemented")
}
func (UnimplementedScoutServiceServer) RightClick(context.Context, *ElementRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RightClick not implemented")
}
func (UnimplementedScoutServiceServer) Hover(context.Context, *ElementRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Hover not implemented")
}
func (UnimplementedScoutServiceServer) Type(context.Context, *TypeRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Type not implemented")
}
func (UnimplementedScoutServiceServer) SelectOption(context.Context, *SelectRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method SelectOption not implemented")
}
func (UnimplementedScoutServiceServer) PressKey(context.Context, *KeyRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method PressKey not implemented")
}
func (UnimplementedScoutServiceServer) GetText(context.Context, *ElementRequest) (*TextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetText not implemented")
}
func (UnimplementedScoutServiceServer) GetAttribute(context.Context, *AttributeRequest) (*TextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAttribute not implemented")
}
func (UnimplementedScoutServiceServer) GetTitle(context.Context, *SessionRequest) (*TextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTitle not implemented")
}
func (UnimplementedScoutServiceServer) GetURL(context.Context, *SessionRequest) (*TextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetURL not implemented")
}
func (UnimplementedScoutServiceServer) Eval(context.Context, *EvalRequest) (*EvalResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Eval not implemented")
}
func (UnimplementedScoutServiceServer) ElementExists(context.Context, *ElementRequest) (*BoolResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ElementExists not implemented")
}
func (UnimplementedScoutServiceServer) Screenshot(context.Context, *ScreenshotRequest) (*ScreenshotResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Screenshot not implemented")
}
func (UnimplementedScoutServiceServer) PDF(context.Context, *SessionRequest) (*PDFResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PDF not implemented")
}
func (UnimplementedScoutServiceServer) StartRecording(context.Context, *RecordingRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method StartRecording not implemented")
}
func (UnimplementedScoutServiceServer) StopRecording(context.Context, *SessionRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method StopRecording not implemented")
}
func (UnimplementedScoutServiceServer) ExportHAR(context.Context, *SessionRequest) (*HARResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExportHAR not implemented")
}
func (UnimplementedScoutServiceServer) StreamEvents(*SessionRequest, grpc.ServerStreamingServer[BrowserEvent]) error {
	return status.Error(codes.Unimplemented, "method StreamEvents not implemented")
}
func (UnimplementedScoutServiceServer) Interactive(grpc.BidiStreamingServer[Command, BrowserEvent]) error {
	return status.Error(codes.Unimplemented, "method Interactive not implemented")
}
func (UnimplementedScoutServiceServer) mustEmbedUnimplementedScoutServiceServer() {}
func (UnimplementedScoutServiceServer) testEmbeddedByValue()                      {}

// UnsafeScoutServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ScoutServiceServer will
// result in compilation errors.
type UnsafeScoutServiceServer interface {
	mustEmbedUnimplementedScoutServiceServer()
}

func RegisterScoutServiceServer(s grpc.ServiceRegistrar, srv ScoutServiceServer) {
	// If the following call panics, it indicates UnimplementedScoutServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ScoutService_ServiceDesc, srv)
}

func _ScoutService_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_CreateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).CreateSession(ctx, req.(*CreateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_DestroySession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).DestroySession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_DestroySession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).DestroySession(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_Navigate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NavigateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).Navigate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_Navigate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).Navigate(ctx, req.(*NavigateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_Reload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).Reload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_Reload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).Reload(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_GoBack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).GoBack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_GoBack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).GoBack(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_GoForward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).GoForward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_GoForward_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).GoForward(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_Click_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).Click(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_Click_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).Click(ctx, req.(*ElementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_DoubleClick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).DoubleClick(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_DoubleClick_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).DoubleClick(ctx, req.(*ElementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_RightClick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).RightClick(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_RightClick_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).RightClick(ctx, req.(*ElementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_Hover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).Hover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_Hover_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).Hover(ctx, req.(*ElementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_Type_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).Type(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_Type_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).Type(ctx, req.(*TypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_SelectOption_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).SelectOption(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_SelectOption_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).SelectOption(ctx, req.(*SelectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_PressKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).PressKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_PressKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).PressKey(ctx, req.(*KeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_GetText_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).GetText(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_GetText_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).GetText(ctx, req.(*ElementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_GetAttribute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttributeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).GetAttribute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_GetAttribute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).GetAttribute(ctx, req.(*AttributeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_GetTitle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).GetTitle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_GetTitle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).GetTitle(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_GetURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).GetURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_GetURL_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).GetURL(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_Eval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).Eval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_Eval_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).Eval(ctx, req.(*EvalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_ElementExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).ElementExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_ElementExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).ElementExists(ctx, req.(*ElementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_Screenshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScreenshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).Screenshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_Screenshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).Screenshot(ctx, req.(*ScreenshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_PDF_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).PDF(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_PDF_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).PDF(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_StartRecording_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).StartRecording(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_StartRecording_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).StartRecording(ctx, req.(*RecordingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_StopRecording_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).StopRecording(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_StopRecording_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).StopRecording(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_ExportHAR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScoutServiceServer).ExportHAR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScoutService_ExportHAR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScoutServiceServer).ExportHAR(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScoutService_StreamEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SessionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ScoutServiceServer).StreamEvents(m, &grpc.GenericServerStream[SessionRequest, BrowserEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ScoutService_StreamEventsServer = grpc.ServerStreamingServer[BrowserEvent]

func _ScoutService_Interactive_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ScoutServiceServer).Interactive(&grpc.GenericServerStream[Command, BrowserEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ScoutService_InteractiveServer = grpc.BidiStreamingServer[Command, BrowserEvent]

// ScoutService_ServiceDesc is the grpc.ServiceDesc for ScoutService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ScoutService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "scout.v1.ScoutService",
	HandlerType: (*ScoutServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSession",
			Handler:    _ScoutService_CreateSession_Handler,
		},
		{
			MethodName: "DestroySession",
			Handler:    _ScoutService_DestroySession_Handler,
		},
		{
			MethodName: "Navigate",
			Handler:    _ScoutService_Navigate_Handler,
		},
		{
			MethodName: "Reload",
			Handler:    _ScoutService_Reload_Handler,
		},
		{
			MethodName: "GoBack",
			Handler:    _ScoutService_GoBack_Handler,
		},
		{
			MethodName: "GoForward",
			Handler:    _ScoutService_GoForward_Handler,
		},
		{
			MethodName: "Click",
			Handler:    _ScoutService_Click_Handler,
		},
		{
			MethodName: "DoubleClick",
			Handler:    _ScoutService_DoubleClick_Handler,
		},
		{
			MethodName: "RightClick",
			Handler:    _ScoutService_RightClick_Handler,
		},
		{
			MethodName: "Hover",
			Handler:    _ScoutService_Hover_Handler,
		},
		{
			MethodName: "Type",
			Handler:    _ScoutService_Type_Handler,
		},
		{
			MethodName: "SelectOption",
			Handler:    _ScoutService_SelectOption_Handler,
		},
		{
			MethodName: "PressKey",
			Handler:    _ScoutService_PressKey_Handler,
		},
		{
			MethodName: "GetText",
			Handler:    _ScoutService_GetText_Handler,
		},
		{
			MethodName: "GetAttribute",
			Handler:    _ScoutService_GetAttribute_Handler,
		},
		{
			MethodName: "GetTitle",
			Handler:    _ScoutService_GetTitle_Handler,
		},
		{
			MethodName: "GetURL",
			Handler:    _ScoutService_GetURL_Handler,
		},
		{
			MethodName: "Eval",
			Handler:    _ScoutService_Eval_Handler,
		},
		{
			MethodName: "ElementExists",
			Handler:    _ScoutService_ElementExists_Handler,
		},
		{
			MethodName: "Screenshot",
			Handler:    _ScoutService_Screenshot_Handler,
		},
		{
			MethodName: "PDF",
			Handler:    _ScoutService_PDF_Handler,
		},
		{
			MethodName: "StartRecording",
			Handler:    _ScoutService_StartRecording_Handler,
		},
		{
			MethodName: "StopRecording",
			Handler:    _ScoutService_StopRecording_Handler,
		},
		{
			MethodName: "ExportHAR",
			Handler:    _ScoutService_ExportHAR_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamEvents",
			Handler:       _ScoutService_StreamEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Interactive",
			Handler:       _ScoutService_Interactive_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "grpc/proto/scout.proto",
}

const (
	PairingService_Pair_FullMethodName = "/scout.v1.PairingService/Pair"
)

// PairingServiceClient is the client API for PairingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// PairingService runs on an insecure listener to exchange certificates
// between devices that want to establish mTLS trust.
type PairingServiceClient interface {
	Pair(ctx context.Context, in *PairRequest, opts ...grpc.CallOption) (*PairResponse, error)
}

type pairingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPairingServiceClient(cc grpc.ClientConnInterface) PairingServiceClient {
	return &pairingServiceClient{cc}
}

func (c *pairingServiceClient) Pair(ctx context.Context, in *PairRequest, opts ...grpc.CallOption) (*PairResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PairResponse)
	err := c.cc.Invoke(ctx, PairingService_Pair_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PairingServiceServer is the server API for PairingService service.
// All implementations must embed UnimplementedPairingServiceServer
// for forward compatibility.
//
// PairingService runs on an insecure listener to exchange certificates
// between devices that want to establish mTLS trust.
type PairingServiceServer interface {
	Pair(context.Context, *PairRequest) (*PairResponse, error)
	mustEmbedUnimplementedPairingServiceServer()
}

// UnimplementedPairingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPairingServiceServer struct{}

func (UnimplementedPairingServiceServer) Pair(context.Context, *PairRequest) (*PairResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Pair not implemented")
}
func (UnimplementedPairingServiceServer) mustEmbedUnimplementedPairingServiceServer() {}
func (UnimplementedPairingServiceServer) testEmbeddedByValue()                        {}

// UnsafePairingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PairingServiceServer will
// result in compilation errors.
type UnsafePairingServiceServer interface {
	mustEmbedUnimplementedPairingServiceServer()
}

func RegisterPairingServiceServer(s grpc.ServiceRegistrar, srv PairingServiceServer) {
	// If the following call panics, it indicates UnimplementedPairingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PairingService_ServiceDesc, srv)
}

func _PairingService_Pair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PairingServiceServer).Pair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PairingService_Pair_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PairingServiceServer).Pair(ctx, req.(*PairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PairingService_ServiceDesc is the grpc.ServiceDesc for PairingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PairingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "scout.v1.PairingService",
	HandlerType: (*PairingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Pair",
			Handler:    _PairingService_Pair_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc/proto/scout.proto",
}
